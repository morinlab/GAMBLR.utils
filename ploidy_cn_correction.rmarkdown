---
title: "battenberg"
format: html
editor: visual
---



## Copy Number: Dealing with missing/NA regions



```{r}
library(GAMBLR)
library(tidyverse)
```



Get all CN segments with or without any pre-processing



```{r}

batt_meta = get_gambl_metadata() %>% 
  dplyr::filter(seq_type!="mrna",
                pathology=="DLBCL")




#get everything but drop the dummy segments
batt_all_nofill = get_cn_segments(flavour="battenberg",
                                  fill_missing_with = "nothing",
                                  these_samples_metadata = batt_meta)

#get everything but fill the dummy segments with average ploidy of all other segments in that sample

batt_all_av = get_cn_segments(flavour="battenberg",
                              fill_missing_with = "avg_ploidy",
                              these = batt_meta)

#get everything but fill the dummy segments with same CN value of 2

batt_all_dip = get_cn_segments(flavour="battenberg",
                               fill_missing_with = "diploid",
                               these = batt_meta)

#drop dummy segments

#batt_all = dplyr::filter(batt_all,dummy_segment == 0)

ggplot(batt_all_nofill,aes(x=CN)) + 
  geom_histogram() + facet_wrap(~dummy_segment,scales="free_y") + xlim(c(0.5,6))

ggplot(batt_all_av,aes(x=CN)) + 
  geom_histogram() + facet_wrap(~dummy_segment,scales="free_y") + xlim(c(0.5,6))

ggplot(batt_all_dip,aes(x=CN)) + 
  geom_histogram() + facet_wrap(~dummy_segment,scales="free_y") + xlim(c(0.5,6))


```



\
Our original paradigm was to set missing segments to diploid. The consequence of this approach is that scaling causes artificially low CN values in all filled regions for high ploidy cases. If we run `segmented_data_to_cn_matrix` with the same setting, this is the result we get.



```{r}
seg_dipfill = segmented_data_to_cn_matrix(batt_all_dip,
                                         n_bins_split=1500,
                                         fill_missing_with = "diploid",
                                         these_samples_metadata = batt_meta)



pretty_CN_heatmap(seg_dipfill,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = F)

pretty_CN_heatmap(seg_dipfill,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = T)

pretty_CN_heatmap(seg_dipfill,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = T,keep_these_chromosomes = "9",
                  show_column_names = T)
```



If we drop the dummy segments by giving `get_cn_segments` the argument `fill_missing_with = "nothing"` we can let `segmented_data_to_cn_matrix` handle missing data in a better way. We can also let missing data stay NA by running `segmented_data_to_cn_matrix` with `fill_missing_with = "nothing"`. This reveals that the large deletions that were mostly unique to high ploidy samples indeed represent regions that are missing data (NA) in many patients.



```{r}


cn_no_no = segmented_data_to_cn_matrix(batt_all_nofill,
                                         n_bins_split=1500,
                                         fill_missing_with = "nothing",
                                         these_samples_metadata = batt_meta)

pretty_CN_heatmap(cn_no_no,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = F)

pretty_CN_heatmap(cn_no_no,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = T)


pretty_CN_heatmap(cn_no_no,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,show_column_names=T,
                  scale_by_sample = T,keep_these_chromosomes = "9")


```



In general, if you set a non-default value for `fill_missing_with` then you should use the same value for any subsequent functions that touch these data. If, however, you leave get_cn_segments with the default setting, it forcibly drops all the *dummy* segments that were added in a post-processing step that was applied for GISTIC. Since they've been dropped, this leaves you free to tell `segmented_data_to_cn_matrix` to apply any filling paradigm to the data. In fact, it may only be useful to run `get_cn_segments` in conjunction with `fill_missing_with="avg_ploidy"` when generating inputs for GISTIC.



```{r}
cn_no_avg = segmented_data_to_cn_matrix(batt_all_nofill,
                                         n_bins_split=1500,
                                         fill_missing_with = "avg_ploidy",
                                         these_samples_metadata = batt_meta)


pretty_CN_heatmap(cn_no_avg,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = F)

pretty_CN_heatmap(cn_no_avg,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = T)


pretty_CN_heatmap(cn_no_avg,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,show_column_names=T,
                  scale_by_sample = T,keep_these_chromosomes = "9")


```



In this example, we can see that following `get_cn_segments(fill_missing_with = "nothing")` with a subsequent call to `segmented_data_to_cn_matrix(fill_missing_with = "diploid")` gives a different result than if we use "diploid" at both steps.



```{r}


### The only one that makes a difference is fill_missing_with = "diploid"
### This is because NA regions are not filled with the average ploidy of the genome

cn_no_dip = segmented_data_to_cn_matrix(batt_all_nofill,
                                         n_bins_split=1500,
                                         fill_missing_with = "diploid",
                                         these_samples_metadata = batt_meta)



pretty_CN_heatmap(cn_no_dip,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = F)

pretty_CN_heatmap(cn_no_dip,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = T)

pretty_CN_heatmap(cn_no_dip,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,show_column_names=T,
                  scale_by_sample = T,keep_these_chromosomes = "9")


```



What if we fill_missing_with "avg_ploidy" at both steps? Is this better or worse than starting with no filling?



```{r}

cn_no_avg = segmented_data_to_cn_matrix(batt_all_av,
                                         n_bins_split=1500,
                                         fill_missing_with = "avg_ploidy",
                                         these_samples_metadata = batt_meta)


pretty_CN_heatmap(cn_no_avg,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = F)

pretty_CN_heatmap(cn_no_avg,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,
                  scale_by_sample = T)


pretty_CN_heatmap(cn_no_avg,
                  sortByPGA = T,
                  cluster_rows = F,
                  these=batt_meta,show_column_names=T,
                  scale_by_sample = T,keep_these_chromosomes = "9")



```



Why does this matter? What causes the difference?

Here are the segments if we apply the averaging up-front



```{r}

dplyr::filter(batt_all_av,chrom=="9", CN < 6) %>% 
#  ,
#              (start < 37380026 & end > 74760050) |
#                                      (end > 37380026 &  end < 74760050) |
#                                      (start > 37380026 & start < 74760050)|
#                                      (end < 74760050 & start > 37380026)) %>%
ggplot(aes(xmin=start,xmax=end,ymin=CN-0.1,ymax=CN+0.1)) + geom_rect(alpha=0.1) +
  theme_Morons()





```



Here are the segments if we skip that step.



```{r}
dplyr::filter(batt_all_nofill,chrom=="9", CN < 6) %>%
           #   (start < 37380026 & end > 74760050) |
          #                            (end > 37380026 &  end < 74760050) |
          #                            (start > 37380026 & start < 74760050)|
          #      (end < 74760050 & start > 37380026)) %>%
ggplot(aes(xmin=start,xmax=end,ymin=CN-0.1,ymax=CN+0.1)) + 
  geom_rect(alpha=0.1) + theme_Morons() 


```

